#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 5563d742-75af-4688-8006-3ca6672e1532
# Source File: CDRDesktopInfo.psproj
#------------------------------------------------------------------------
#region Project Recovery Data (DO NOT MODIFY)
<#RecoveryData:
UgIAAB+LCAAAAAAABACFUltPgzAYfV+y/0D6aMK4bLAlsj4owezBS2Dx1VT4kLrSklLm5q+3UGa2
qPHla097OCfn0CiFXOxBHmOiCJ5OLCt6kuIdcmVlR55XUnD6CcUaJYS1gIbDhDIFco2uZk3rXfez
NkthFu9Qs2FTDrPV05xUwJqZOig0GGmrZ5AtFRz7My9yTmC80y6wiXEQhPNiufDtZUBKexGuVvbK
dUN7npMwXPrgBXM/ckby+OmYYHtsALuRcw5P4oIV2s5yzt3aEYzQuuko08ldhDNFpOqaPozx+otp
ZRWRfV1b2em2UihBAs8h6XiudLg12vC92IF9x8QrYS+6LITNvu2b+0f9F72sEh/2PaE8EbLWeiXC
J9T/gQtBA0zM71oMepT0jXLCesIDqQHfxmkM7U6JZsNLoaUaTY+cH7zpJHIu3tAXPK6RTlICAAA=#>
#endregion
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.155
     Generated on:       11/13/2018 7:27 PM
     Generated by:       Carl Roach
     Organization:       Cerner Corporation
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>



#region Source: Startup.pss
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
YQAAAB+LCAAAAAAABACzCUpNzi9LLap0SSxJVAAyijPz82yVjPUMlex4uRQUbPyLMtMz8xJz3DJz
Uv0Sc1PtgksSi0pKC/QKiott9DFkebls9JGNtAMAoyFkEGEAAAA=#>
#endregion
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main
{
	###########################################################################################
	#
	# Cerner Desktop Info
	# Created On:  11/13/18
	# Script Name: CDRDesktopInfo.ps1
	# 
	#==========================================================================================
	# Script designed to show relevant server info on the desktop of Windows Servers
	#
	# Version 1.0.0.0 	- CR026943 - 05/08/18 - Initial Creation of v1
	#
	# All rights reserved - Do Not Redistribute
	#
	# Carl Roach, Technical Architect, CSM Transition Team
	# carl.roach@cerner.com
	#==========================================================================================
	# To Do List:
	###########################################################################################
	
<#
.SYNOPSIS
App designed to display relevant server info on the desktop.
 
.DESCRIPTION
This app on first run will ask you to configure server support info, and will skip the gui on subsequent launches.

.NOTES

 #>
	
	Param ([String]$Commandline)
	
	#--------------------------------------------------------------------------
	
	
	
	#--------------------------------------------------------------------------
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	$LocalDesktopInfoPath = 'c:\Scripts\CDRDesktopInfo.exe'

	$Global:DesktopInfoPathTest = (Test-Path $LocalDesktopInfoPath -ErrorAction SilentlyContinue)
	
	$UpdateCheck = (Test-Path 'c:\Scripts\cdrdesktopinfo.exe')
	If ($UpdateCheck -eq $True)
	{
		$AppInstalledVersion = ((get-item C:\scripts\cdrdesktopinfo.exe).VersionInfo | select-object FileVersion).FileVersion
	}
	$AppCurrentVersion = $appversion
	If ($DesktopInfoPathTest -eq $False) { Show-MainForm_psf }
	elseif (($DesktopInfoPathTest -eq $True) -and ($UpdateCheck -eq $False)) { Show-MainForm_psf }
	elseif (($DesktopInfoPathTest -eq $True) -and ($UpdateCheck -eq $True) -and ($appcurrentversion -gt $AppInstalledVersion)) { Show-MainForm_psf }
	else { DesktopInfo }
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}
#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	$appversion = "1.0.0.0"
	$About_Date = "11/13/18"
	$ScriptDirectory = (Get-Item -Path ".\" -Verbose).FullName
	$Programs64 = "$Env:ProgramFiles"
	$Programs86 = "$Env:ProgramFiles(x86)"
	$ThisServer = $env:COMPUTERNAME
	
	$LocalDesktopInfoPath = 'c:\Scripts\CDRDesktopInfo.exe'
	
	function DesktopInfo
	{
		# Configuration:
		
		# Font Family name
		$font = "Verdana"
		# Font size in pixels
		$size = 10.0
		# spacing in pixels
		$textPaddingLeft = 10
		$textPaddingTop = 10
		$textItemSpace = 4
		#$lineHeight = 1.80
		
		$wallpaperImageOutput = "$Env:USERPROFILE"
		
		# Get local info to write out to wallpaper
		$HostName = $Env:ComputerName
		$AuthenticatedUsers = "Authenticated Users"
		$os = Get-CimInstance Win32_OperatingSystem
		$DiskInfo = Get-CimInstance Win32_LogicalDisk | where FreeSpace -gt 1
		$cpu = (get-WmiObject Win32_Processor).Name | get-unique
		$cpulogical = (get-WmiObject Win32_ComputerSystem).NumberOfLogicalProcessors
		$BootTime = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
		$BootTimeConverted = ($boottime.toString("M/d/yyyy h:mm tt"))
		$BootTimeSpan = (New-TimeSpan -Start $os.LastBootUpTime -End (Get-Date))
		$logondata = query user
		$LoginTime = ($LogonData.Split()[-3, -2, -1]) -join (" ")
		$ipinfo = (get-WmiObject Win32_NetworkAdapterConfiguration | Where { $_.DefaultIPGateway -gt 1 }).IPAddress
		$subnetmask = (get-WmiObject Win32_NetworkAdapterConfiguration | Where { $_.DefaultIPGateway -gt 1 }).IPSubnet | get-unique
		$gateway = (get-WmiObject Win32_NetworkAdapterConfiguration | Where { $_.DefaultIPGateway -gt 1 }).DefaultIPGateway
		$dnsservers = (get-WmiObject Win32_NetworkAdapterConfiguration | Where { $_.DefaultIPGateway -gt 1 }).DNSServerSearchOrder
		$ServerName = (get-WmiObject Win32_ComputerSystem | Where { $_.Name -gt 1 }).Name
		$MachineDomain = (get-wmiobject -class win32_computersystem).domain
		$ADDomain = $env:userdomain
		$LogonServer = $env:logonserver -replace "\\", ""
		
		$DiskArray = @()
		foreach ($Disk in $DiskInfo)
		{
			$DiskName = $Disk.Name
			$DiskFree = "$([Int]($Disk.FreeSpace / 1GB))GB"
			$DiskFS = $Disk.FileSystem
			$DiskSpace = "$DiskName $DiskFree $DiskFS"
			$DiskArray += "$DiskSpace `n"
		}
		
		$NetworkArray = @()
		foreach ($IP in $IPInfo)
		{
			$IPAddress = $IP.IPAddress
			$IPMask = $IP.IPSubnet
			$IPGateway = $IP.DefaultGateway
			$NetworkArray += "$IPAddress `n"
		}
		
	
		# Populate Info for Displaying on Desktop
		
		$ComputerInfo = ([ordered]@{
				"HostName:"		      = $HostName
	
				"Uptime:"			  = "$($BootTimeSpan.Days) days, $($BootTimeSpan.Hours) hours  `n"
				"Domain/Workgroup:"	  = $MachineDomain
				"OS Version:"		  = $($os.Caption)
				"Architecture:"	      = $($os.OSArchitecture)
				"Boot Time:"		  = $BootTimeConverted
				"Login Time:"		  = "$LoginTime   `n"
				"IP Address:"		  = $IPInfo
				"Subnet Mask:"	      = $subnetmask
				"Default Gateway:"    = $gateway
				"DNS Servers:"	      = "$dnsservers `n"
				"User Name:"		  = $env:UserName
				"Logon Domain:"	      = $ADDomain
				"Logon Server:"	      = "$LogonServer `n"
				"CPU:"			      = "$cpulogical x $cpu"
				"Memory:"			  = "$([math]::round($os.TotalVisibleMemorySize / 1MB))GB    `n"
				
				"Free Space:"		  = $DiskArray
			})
		
		
		
		# original src: https://p0w3rsh3ll.wordpress.com/2014/08/29/poc-tatoo-the-background-of-your-virtual-machines/
		Function New-ImageInfo
		{
			param (
				[Parameter(Mandatory = $True, Position = 1)]
				[object]$data,
				[Parameter(Mandatory = $True)]
				[string]$in = "",
				[string]$font = "Verdana",
				[float]$size = 8.0,
				#[float] $lineHeight = 1.4,
				[float]$textPaddingLeft = 0,
				[float]$textPaddingTop = 0,
				[float]$textItemSpace = 0,
				[string]$out = "out.png"
			)
			
			
			[system.reflection.assembly]::loadWithPartialName('system') | out-null
			[system.reflection.assembly]::loadWithPartialName('system.drawing') | out-null
			[system.reflection.assembly]::loadWithPartialName('system.drawing.imaging') | out-null
			[system.reflection.assembly]::loadWithPartialName('system.windows.forms') | out-null
			
			$foreBrush = [System.Drawing.Brushes]::White
			$foreBrush2 = [System.Drawing.Brushes]::Yellow
			$backBrush = new-object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(0, 0, 0, 0))
			
			# Create font
	#		$nFont = new-object system.drawing.font($font, $size, [System.Drawing.GraphicsUnit]::Pixel)
			$nFont = new-object System.Drawing.Font($font, $size, "Bold", "Pixel")
			
			# Create Bitmap
			$SR = [System.Windows.Forms.Screen]::AllScreens | Where Primary | Select -ExpandProperty Bounds | Select Width, Height
			
			echo $SR >> "$wallpaperImageOutput\wallpaper.log"
			
			$background = new-object system.drawing.bitmap($SR.Width, $SR.Height)
			#   $bmp = new-object system.drawing.bitmap -ArgumentList $in
			
			# Create Graphics
			$image = [System.Drawing.Graphics]::FromImage($background)
			
			# Paint image's background
			$rect = new-object system.drawing.rectanglef(0, 0, $SR.width, $SR.height)
			$image.FillRectangle($backBrush, $rect)
			
			# add in image
			$topLeft = new-object System.Drawing.RectangleF(0, 0, $SR.Width, $SR.Height)
			#  $image.DrawImage($bmp, $topLeft)
			
			# Draw string
			$strFrmt = new-object system.drawing.stringformat
			$strFrmt.Alignment = [system.drawing.StringAlignment]::Near
			$strFrmt.LineAlignment = [system.drawing.StringAlignment]::Near
			
			$taskbar = [System.Windows.Forms.Screen]::AllScreens
			$taskbarOffset = $taskbar.Bounds.Height - $taskbar.WorkingArea.Height
			
			# first get max key & val widths
			$maxKeyWidth = 0
			$maxValWidth = 0
			$textBgHeight = 0 + $taskbarOffset
			$textBgWidth = 0
			
			# a reversed ordered collection is used since it starts from the bottom
			$reversed = [ordered]@{ }
			
			foreach ($h in $data.GetEnumerator())
			{
				$valString = "$($h.Value)"
				$valFont = New-Object System.Drawing.Font($font, $size, [System.Drawing.FontStyle]::Bold)
				$valSize = [system.windows.forms.textrenderer]::MeasureText($valString, $valFont)
				$maxValWidth = [math]::Max($maxValWidth, $valSize.Width)
				
				$keyString = "$($h.Name):"
				$keyFont = New-Object System.Drawing.Font($font, $size, [System.Drawing.FontStyle]::Regular)
				$keySize = [system.windows.forms.textrenderer]::MeasureText($keyString, $keyFont)
				$maxKeyWidth = [math]::Max($maxKeyWidth, $keySize.Width)
				
				$maxItemHeight = [math]::Max($valSize.Height, $keySize.Height)
				$textBgHeight += ($maxItemHeight + $textItemSpace)
				
				$reversed.Insert(0, $h.Name, $h.Value)
			}
			
			$textBgWidth = $maxKeyWidth + $maxValWidth
			$textBgX = $SR.Width - ($textBgWidth + $textPaddingLeft)
			$textBgY = $SR.Height - ($textBgHeight + $textPaddingTop)
			
			$textBgRect = New-Object System.Drawing.RectangleF($textBgX, $textBgY, $textBgWidth, $textBgHeight)
			$image.FillRectangle($backBrush, $textBgRect)
			
			echo $textBgRect >> "$wallpaperImageOutput\wallpaper.log"
			
			$i = 0
			$cumulativeHeight = $SR.Height - $taskbarOffset
			
			foreach ($h in $reversed.GetEnumerator())
			{
				$valString = "$($h.Value)"
				$valFont = New-Object System.Drawing.Font($font, $size, [System.Drawing.FontStyle]::Bold)
				$valSize = [system.windows.forms.textrenderer]::MeasureText($valString, $valFont)
				
				$keyString = "$($h.Name)"
				$keyFont = New-Object System.Drawing.Font($font, $size, [System.Drawing.FontStyle]::Regular)
				$keySize = [system.windows.forms.textrenderer]::MeasureText($keyString, $keyFont)
				
				
				echo $valString >> "$wallpaperImageOutput\wallpaper.log"
				echo $keyString >> "$wallpaperImageOutput\wallpaper.log"
				
				$maxItemHeight = [math]::Max($valSize.Height, $keySize.Height) + $textItemSpace
				
				$valX = $SR.Width - $maxValWidth
				$valY = $cumulativeHeight - $maxItemHeight
				
				$keyX = $valX - $maxKeyWidth
				$keyY = $valY
				
				$valRect = New-Object System.Drawing.RectangleF($valX, $valY, $maxValWidth, $valSize.Height)
				$keyRect = New-Object System.Drawing.RectangleF($keyX, $keyY, $maxKeyWidth, $keySize.Height)
				
				$cumulativeHeight = $valRect.Top
				
				$image.DrawString($keyString, $keyFont, $foreBrush, $keyRect, $strFrmt)
				$image.DrawString($valString, $valFont, $foreBrush2, $valRect, $strFrmt)
				
				$i++
			}
			
			# Close Graphics
			$image.Dispose();
			
			# Save and close Bitmap
			$background.Save($out, [system.drawing.imaging.imageformat]::Png);
			$background.Dispose();
			#  $bmp.Dispose();
			
			# Output file
			Get-Item -Path $out
		}
		
		function Set-Wallpaper
		{
			param (
				[Parameter(Mandatory = $true)]
				$Path,
				[ValidateSet('Center', 'Stretch')]
				$Style = 'Stretch'
			)
			
			Add-Type @"
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32;
namespace Wallpaper
{
public enum Style : int
{
Center, Stretch
}
public class Setter {
public const int SetDesktopWallpaper = 20;
public const int UpdateIniFile = 0x01;
public const int SendWinIniChange = 0x02;
[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
private static extern int SystemParametersInfo (int uAction, int uParam, string lpvParam, int fuWinIni);
public static void SetWallpaper ( string path, Wallpaper.Style style ) {
SystemParametersInfo( SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange );
RegistryKey key = Registry.CurrentUser.OpenSubKey("Control Panel\\Desktop", true);
switch( style )
{
case Style.Stretch :
key.SetValue(@"WallpaperStyle", "2") ; 
key.SetValue(@"TileWallpaper", "0") ;
break;
case Style.Center :
key.SetValue(@"WallpaperStyle", "1") ; 
key.SetValue(@"TileWallpaper", "0") ; 
break;
}
key.Close();
}
}
}
"@
			
			[Wallpaper.Setter]::SetWallpaper($Path, $Style)
		}
		
		$wpath = (Get-ItemProperty 'HKCU:\Control Panel\Desktop' -Name WallPaper -ErrorAction Stop).WallPaper
		if (Test-Path -Path $wpath -PathType Leaf)
		{
			$bmp = new-object system.drawing.bitmap -ArgumentList $wpath
			$currentwallpaper = [System.Drawing.Graphics]::FromImage($bmp)
		}
		
		# execute tasks
		echo $ComputerInfo > "$wallpaperImageOutput\wallpaper.log"
		
		# create wallpaper image and save it in user profile
		$WallPaper = New-ImageInfo -data $ComputerInfo -in "$currentwallpaper" -out "$wallpaperImageOutput\wallpaper.png" -font $font -size $size -textPaddingLeft $textPaddingLeft -textPaddingTop $textPaddingTop -textItemSpace $textItemSpace #-lineHeight $lineHeight
		echo $WallPaper.FullName >> "$wallpaperImageOutput\wallpaper.log"
		
		# update wallpaper for logged in user
		Set-Wallpaper -Path $WallPaper.FullName
		
		# Restore the default VM wallpaper
	#	Set-Wallpaper -Path "C:\Windows\Web\Wallpaper\Windows\img0.jpg" -Style Fill
	}
	
#endregion Source: Globals.ps1

#region Source: MainForm.psf
function Show-MainForm_psf
{
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
HwQAAB+LCAAAAAAABABllFmLq1oQhd8D+Q/NeRWOxiEa6G4w7jhP0Ti+GaPu7RCNQ6L++pPb9+XA
qaeiFgUFa3316WRp+8z6BSRj8vFuBtTev35Rv3e/vrebj49Pq0cFuie1iOrMTJrs20jQXWz75nc3
5J/4P/LP0n/6t0ar847n4P018LxgAYH/v448MP16Z5Mr7+UxRuAkqCOPc/CAOSaLNWpeoUgahOzx
xKwNNe9H5LDRTD4pmtpu3MtASjCmTg16iCAc7TwHB2a5lBpeXjlhEG57XCGdlHIEdgkAcpyxVC7U
fmkCJA+U09zU7pb7KuVz2HYznc1xUrULXkssZhfVqoSm6b0qRowvdGxd7WOShilo/MeOv0y6g3g2
isyC2ecBzMMVnbz60usrn9s53G6ugAYDqzwsJtUZRyZfpwCdskB068cIbVnrenmU9sRCyMkKwwMC
QGHXZOenMANeaEa8pcRXw0bGBN63hcdOh/lRSZhsGtMn5T3Z9NFCh79YWYFmaa4TyZ7uBKWJoVac
npZhqlIpQVo4jrPMFZHJ51hyydnSFbYb1PlG7TG8Q0UlqlUOpI3h7aWgzPh+mqJu100P86x1hskb
dK6eFynjsko2ezg5VRImFCqB7nKkbOnzdvO21nhbK7ECOeie2qSsNrpWp5vVBJUR9YgUdYLhUcqF
eSwCYA5VVtuJ8EgVTzMHJlzZgSOJ3D+I1XYDivh6aPVeeOVKF2gEWcVPaNgkrAzZMwLefsXEWfQ1
id9xxEiEoUEJSfiaTsQxuVXpRLsebo88gWFlut0QTgpar11t5RidVbEANXRS9k4U9XRjiQmag3cz
18rv/OVeaztBjfrbLtPlPnpkbOMeOiApPpY9NK3lthtvtd2bIYVTwrapA3GBTYcR29Hokbl0kbj1
vLQriurrc9KMPWkEdeF6Qa1Abby2KmEbczbbQMIJjEDbzTvLMaaQd8ZdpLDPQNMMeadcDzGN+iBW
QbPOkUznK0ZSJmam7IvCn/OTgk/2Pt8GPRwl4z6Ve2YIR/mdN5KVEcAPJeLgZTkMVzvkVAvXQy4b
jV6wmB6/sfo+oYXUbdau+CGR//r6xH8A/UGVH4asudYoGz7w9+QT//shfP8BB58E+B8EAAA=#>
#endregion
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form_CDRDesktopInfo = New-Object 'System.Windows.Forms.Form'
	$button_Cancel = New-Object 'System.Windows.Forms.Button'
	$label_CDRDesktopInfoConfiguration = New-Object 'System.Windows.Forms.Label'
	$button_Install = New-Object 'System.Windows.Forms.Button'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	
	Import-Module ScheduledTasks
	$form_CDRDesktopInfo_Load={
	}
	
	
	$Server = $env:computername
	$ServerFQDN = ([System.Net.Dns]::GetHostByName($Server)).hostname
	
	function Configure-DesktopInfo
	{
		#Remove BGInfo
		Get-Childitem –Path 'C:\scripts\bginfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'C:\Documents and Settings\All Users\Start Menu\Programs\Startup\bginfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'C:\temp\bginfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'c:\Windows\bginfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\bginfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\*.bgi' -File -ErrorAction SilentlyContinue | rm
		
		#Remove Old Desktop Info Script
		Get-Childitem –Path 'C:\scripts\DesktopInfo.*' -File -ErrorAction SilentlyContinue | rm
		Get-Childitem –Path 'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\*DesktopInfo*' -File -Recurse -ErrorAction SilentlyContinue | rm
		
		$OSVER = (Get-WmiObject -class Win32_OperatingSystem).Caption
		
		$Source = "$ScriptDirectory\CDRDesktopInfo.exe"
		$Dest = "c:\Scripts\CDRDesktopInfo.exe"
		Copy-Item $Source $dest -force
			
		$ShedService = New-Object -comobject 'Schedule.Service'
		$ShedService.Connect()
			
		$Task = $ShedService.NewTask(0)
		$Task.RegistrationInfo.Description = 'CDR Desktop Info'
		$Task.Settings.Enabled = $true
		$Task.Settings.AllowDemandStart = $true
			
		$trigger = $task.triggers.Create(9)
		$trigger.Enabled = $true
			
		$action = $Task.Actions.Create(0)
		$action.Path = 'C:\scripts\cdrdesktopinfo.exe'
		$action.Arguments = ''
			
		$Principal = $Task.Principal
		$Principal.RunLevel = 1
		
		$taskFolder = $ShedService.GetFolder("\")
		$taskFolder.RegisterTaskDefinition('CDR Desktop Info', $Task, 6, 'Users', $null, 4)
	}
	
	
	$button_Install_Click = {
		Configure-DesktopInfo
		DesktopInfo
	}#end buttonInstall_Click
	
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form_CDRDesktopInfo.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$button_Install.remove_Click($button_Install_Click)
			$form_CDRDesktopInfo.remove_Load($Form_StateCorrection_Load)
			$form_CDRDesktopInfo.remove_Closing($Form_StoreValues_Closing)
			$form_CDRDesktopInfo.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form_CDRDesktopInfo.SuspendLayout()
	#
	# form_CDRDesktopInfo
	#
	$form_CDRDesktopInfo.Controls.Add($button_Cancel)
	$form_CDRDesktopInfo.Controls.Add($label_CDRDesktopInfoConfiguration)
	$form_CDRDesktopInfo.Controls.Add($button_Install)
	$form_CDRDesktopInfo.AcceptButton = $button_Install
	$form_CDRDesktopInfo.AutoScaleDimensions = '6, 13'
	$form_CDRDesktopInfo.AutoScaleMode = 'Font'
	$form_CDRDesktopInfo.ClientSize = '547, 401'
	$form_CDRDesktopInfo.FormBorderStyle = 'FixedDialog'
	$form_CDRDesktopInfo.MaximizeBox = $False
	$form_CDRDesktopInfo.MinimizeBox = $False
	$form_CDRDesktopInfo.Name = 'form_CDRDesktopInfo'
	$form_CDRDesktopInfo.StartPosition = 'CenterScreen'
	$form_CDRDesktopInfo.Text = 'CDR Desktop Info'
	#
	# button_Cancel
	#
	$button_Cancel.Anchor = 'Bottom, Right'
	$button_Cancel.DialogResult = 'OK'
	$button_Cancel.Location = '370, 366'
	$button_Cancel.Name = 'button_Cancel'
	$button_Cancel.Size = '75, 23'
	$button_Cancel.TabIndex = 27
	$button_Cancel.Text = '&Cancel'
	$button_Cancel.UseCompatibleTextRendering = $True
	$button_Cancel.UseVisualStyleBackColor = $True
	#
	# label_CDRDesktopInfoConfiguration
	#
	$label_CDRDesktopInfoConfiguration.AutoSize = $True
	$label_CDRDesktopInfoConfiguration.Enabled = $False
	$label_CDRDesktopInfoConfiguration.Font = 'Microsoft Sans Serif, 16pt'
	$label_CDRDesktopInfoConfiguration.Location = '122, 18'
	$label_CDRDesktopInfoConfiguration.Name = 'label_CDRDesktopInfoConfiguration'
	$label_CDRDesktopInfoConfiguration.Size = '321, 30'
	$label_CDRDesktopInfoConfiguration.TabIndex = 1
	$label_CDRDesktopInfoConfiguration.Text = 'CDR Desktop Info Configuration'
	$label_CDRDesktopInfoConfiguration.UseCompatibleTextRendering = $True
	#
	# button_Install
	#
	$button_Install.Anchor = 'Bottom, Right'
	$button_Install.DialogResult = 'OK'
	$button_Install.Location = '460, 366'
	$button_Install.Name = 'button_Install'
	$button_Install.Size = '75, 23'
	$button_Install.TabIndex = 0
	$button_Install.Text = '&Install'
	$button_Install.UseCompatibleTextRendering = $True
	$button_Install.UseVisualStyleBackColor = $True
	$button_Install.add_Click($button_Install_Click)
	$form_CDRDesktopInfo.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form_CDRDesktopInfo.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form_CDRDesktopInfo.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form_CDRDesktopInfo.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$form_CDRDesktopInfo.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $form_CDRDesktopInfo.ShowDialog()

}
#endregion Source: MainForm.psf

#Start the application
Main ($CommandLine)
